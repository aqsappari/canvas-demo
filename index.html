<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Demo</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        overflow: hidden;
        cursor: none; /* Hide default cursor */
        background-color: #f0f0f0; /* Light background for contrast */
      }

      p {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #333; /* Darker text for readability */
        font-size: 28px; /* Slightly larger font */
        font-family: "Inter", sans-serif; /* Modern font */
        font-weight: bold;
        background-color: rgba(255, 255, 255, 0.7);
        padding: 10px 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      canvas {
        background-color: #eee;
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 15px; /* Rounded corners for the canvas */
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      }
    </style>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <canvas></canvas>
    <p>Score: <span>0</span></p>
    <script>
      // Canvas Definition
      const canvas = document.querySelector("canvas");
      const c = canvas.getContext("2d");

      // Score Element
      const scoreElement = document.querySelector("p span");
      let score = 0; // Initialize score

      // Initialization of Constants
      const colors = [
        "#FF5733", // Orange-Red (Mouse)
        "#33FF57", // Green (Ball)
        "#3357FF", // Blue (Hole active)
        "#F0F0F0", // Light Gray (unused)
        "#000000", // Black (Hole default)
        "#FF33A1", // Pink (unused)
        "#33FFF5", // Cyan (unused)
        "#FF8C33", // Dark Orange (unused)
      ];
      const initialBallRadius = 20;
      const holeRadius = 70;
      const suckForce = 0.08; // How strongly the hole pulls the ball (adjusted for smoother animation)
      const shrinkRate = 0.8; // How fast the ball shrinks (applied multiplicatively)
      const holeResetDelay = 500; // Delay after ball is fully sucked in before reset (0.5 seconds)
      const minBallRadius = 1; // Minimum radius before ball is considered fully sucked

      const mouse = {
        x: undefined,
        y: undefined,
      };

      // Initialization of Variables
      let circleMouse;
      let circleObject;
      let holes = []; // Use an array to manage holes more easily

      // Event Listeners
      window.addEventListener("mousemove", (event) => {
        mouse.x = event.x;
        mouse.y = event.y;
      });

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        init(); // Reinitialize on resize to adjust positions
      });

      // Circle Class
      class Circle {
        constructor(x, y, dx, dy, radius, color) {
          this.x = x;
          this.y = y;
          this.dx = dx;
          this.dy = dy;
          this.radius = radius;
          this.color = color;
          this.initialRadius = radius; // Store initial radius for reset
          this.isSucked = false; // New state for sucking animation
          this.targetHole = null; // Reference to the hole being sucked into
        }

        draw() {
          c.beginPath();
          c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
          c.fillStyle = this.color;
          c.fill();
          c.closePath();
        }

        update() {
          // If the ball is currently being sucked into a hole
          if (this.isSucked && this.targetHole) {
            // Calculate vector from ball to hole center
            const dxToHole = this.targetHole.x - this.x;
            const dyToHole = this.targetHole.y - this.y;
            const distToHole = Math.sqrt(
              dxToHole * dxToHole + dyToHole * dyToHole
            );

            // Move towards the hole's center with a continuous pull
            if (distToHole > 1) {
              // Apply pull until very close to prevent jitter
              this.dx += dxToHole * suckForce; // Apply force
              this.dy += dyToHole * suckForce; // Apply force

              // Dampen velocity to prevent overshooting and oscillations
              this.dx *= 0.95; // Adjust damping factor
              this.dy *= 0.95; // Adjust damping factor
            } else {
              this.dx = 0; // Snap to exact center when very close
              this.dy = 0;
              this.x = this.targetHole.x;
              this.y = this.targetHole.y;
            }

            // Gradually shrink the radius
            if (this.radius > minBallRadius) {
              this.radius *= shrinkRate; // Multiplicative shrink
            } else {
              this.radius = 0; // Ensure it disappears fully
            }

            // Check if sucking animation is complete (very small and at center)
            if (this.radius <= minBallRadius && distToHole <= 1) {
              this.isSucked = false; // End sucking animation state
              const suckedHole = this.targetHole; // Store reference for reset
              this.targetHole = null; // Clear target hole reference

              // Reset ball and hole after a short delay
              setTimeout(() => {
                this.radius = this.initialRadius;
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.dx = 2; // Give it initial velocity again
                this.dy = 2;
                if (suckedHole) {
                  suckedHole.color = colors[4]; // Reset hole color
                }
              }, holeResetDelay);
            }
          } else {
            // Normal movement logic (if not being sucked)

            // Bounce off the mouse circle
            const distX = this.x - circleMouse.x;
            const distY = this.y - circleMouse.y;
            const distance = Math.sqrt(distX * distX + distY * distY);

            if (distance < this.radius + circleMouse.radius) {
              const angle = Math.atan2(distY, distX);
              this.dx = Math.cos(angle) * 5; // Push away speed
              this.dy = Math.sin(angle) * 5; // Push away speed
            }

            // Bounce off the edges of the canvas
            if (
              this.x + this.radius > canvas.width ||
              this.x - this.radius < 0
            ) {
              this.dx = -this.dx;
            }
            if (
              this.y + this.radius > canvas.height ||
              this.y - this.radius < 0
            ) {
              this.dy = -this.dy;
            }

            // Handle potential hole collisions (only if not already being sucked)
            this.handleHoleCollisions();
          }

          // Update position based on dx and dy for both normal and sucking states
          this.x += this.dx;
          this.y += this.dy;

          this.draw();
        }

        handleHoleCollisions() {
          holes.forEach((hole) => {
            // Check if ball is already being sucked by *any* hole to prevent multiple triggers
            if (this.isSucked) return;

            const distanceToHole = Math.sqrt(
              (this.x - hole.x) ** 2 + (this.y - hole.y) ** 2
            );

            // If the ball enters the hole's influence (defined by radius)
            if (distanceToHole < this.radius + hole.radius - 10) {
              // Slight buffer for entry
              this.isSucked = true; // Start sucking animation
              this.targetHole = hole; // Set target hole
              hole.color = colors[2]; // Change hole color immediately

              // Increment score
              score++;
              scoreElement.textContent = score;

              // Immediately reduce current velocity to start the suck animation smoothly
              this.dx *= 0.5; // Dampen current velocity
              this.dy *= 0.5; // Dampen current velocity
            }
          });
        }

        mouseUpdate() {
          this.x = mouse.x;
          this.y = mouse.y;
          this.draw();
        }
      }

      function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        circleObject = new Circle(
          centerX,
          centerY,
          2, // Initial velocity for the ball
          2,
          initialBallRadius,
          colors[1]
        );

        circleMouse = new Circle(undefined, undefined, 0, 0, 30, colors[0]);

        holes = [
          new Circle(0, 0, 0, 0, holeRadius, colors[4]), // Top Left
          new Circle(canvas.width, 0, 0, 0, holeRadius, colors[4]), // Top Right
          new Circle(0, canvas.height, 0, 0, holeRadius, colors[4]), // Bottom Left
          new Circle(canvas.width, canvas.height, 0, 0, holeRadius, colors[4]), // Bottom Right
        ];

        score = 0; // Reset score on init
        scoreElement.textContent = score;
      }

      function animate() {
        requestAnimationFrame(animate);
        c.clearRect(0, 0, canvas.width, canvas.height);

        // Draw all holes
        holes.forEach((hole) => hole.draw());

        circleObject.update();
        circleMouse.mouseUpdate();
      }

      // Initial setup
      init();
      animate();
    </script>
  </body>
</html>
